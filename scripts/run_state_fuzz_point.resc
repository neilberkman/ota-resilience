# State-fuzz point run for OTA bootloader testing.
#
# Injects a pre-generated NVM state (metadata replicas + slot vectors) and
# then boots the machine to observe bootloader slot selection behavior.
#
# Required monitor variables:
#   $fuzz_setup_script (string path) — Python file that defines a `setup(bus)` function
#                                       to write NVM state via bus.WriteDoubleWord calls.
#   $result_file (string path)       — Where to write the JSON result.
#
# Optional monitor variables:
#   $evaluation_mode ("execute" or "state") — Whether to actually boot or just
#                                              analyze NVM state statically.
#   $scenario_index (int)                   — Index label for result tracking.

$evaluation_mode?="execute"
$scenario_index?=0

python """
import json
import struct
import sys

bus = monitor.Machine.SystemBus

fuzz_setup_script = str(monitor.GetVariable('fuzz_setup_script'))
result_file = str(monitor.GetVariable('result_file'))
evaluation_mode = str(monitor.GetVariable('evaluation_mode')).strip().lower()
if evaluation_mode not in ('execute', 'state'):
    evaluation_mode = 'execute'

try:
    scenario_index = int(monitor.GetVariable('scenario_index'))
except Exception:
    scenario_index = 0

def as_int(value):
    try:
        return int(value)
    except Exception:
        return int(str(value), 0)

# ---------------------------------------------------------------------------
# CRC-32 matching boot_meta.h
# ---------------------------------------------------------------------------

def boot_meta_crc_words(words):
    crc = 0xFFFFFFFF
    for w in words[:-1]:
        for shift in (0, 8, 16, 24):
            crc ^= (w >> shift) & 0xFF
            for _ in range(8):
                crc = (crc >> 1) ^ (0xEDB88320 if (crc & 1) else 0)
            crc &= 0xFFFFFFFF
    return (~crc) & 0xFFFFFFFF

def seq_ge(a, b):
    return ((a - b) & 0xFFFFFFFF) < 0x80000000

# ---------------------------------------------------------------------------
# Execute the setup script to inject NVM state
# ---------------------------------------------------------------------------

# The setup script is a Python file that, when exec'd, makes WriteDoubleWord
# calls on `bus` to populate NVM with the fuzz scenario state.
with open(fuzz_setup_script, 'r') as f:
    setup_code = f.read()
exec(setup_code, {'bus': bus, 'monitor': monitor})

# ---------------------------------------------------------------------------
# Read back metadata replicas to understand what we injected
# ---------------------------------------------------------------------------

def read_replica(addr):
    words = []
    for i in range(64):
        words.append(as_int(bus.ReadDoubleWord(addr + i * 4)))
    valid = (words[0] == 0x4F54414D) and (words[-1] == boot_meta_crc_words(words))
    return {
        'valid': valid,
        'seq': words[1],
        'active_slot': words[2],
        'target_slot': words[3],
        'state': words[4],
        'boot_count': words[5],
        'max_boot_count': words[6],
        'crc_stored': '0x{0:08X}'.format(words[-1]),
        'crc_computed': '0x{0:08X}'.format(boot_meta_crc_words(words)),
    }

def slot_base(slot_id):
    return 0x10039000 if slot_id == 1 else 0x10002000

def slot_vector_valid(slot_id):
    base = slot_base(slot_id)
    sp = as_int(bus.ReadDoubleWord(base + 0))
    reset_vector = as_int(bus.ReadDoubleWord(base + 4))
    reset_pc = reset_vector & ~1
    return (
        (0x20000000 <= sp <= 0x20020000)
        and ((reset_vector & 1) == 1)
        and (base <= reset_pc < (base + 0x37000))
    )

r0 = read_replica(0x10070000)
r1 = read_replica(0x10070100)

# ---------------------------------------------------------------------------
# Oracle: determine which slot the bootloader SHOULD select
# ---------------------------------------------------------------------------

selected = None
if r0['valid'] and r1['valid']:
    selected = r0 if seq_ge(r0['seq'], r1['seq']) else r1
elif r0['valid']:
    selected = r0
elif r1['valid']:
    selected = r1

requested_slot = selected['active_slot'] if selected is not None else 0

# Apply fallback logic.
predicted_slot = -1
if requested_slot in (0, 1):
    if slot_vector_valid(requested_slot):
        predicted_slot = requested_slot
    else:
        other = 1 if requested_slot == 0 else 0
        predicted_slot = other if slot_vector_valid(other) else -1
else:
    # Invalid slot ID — try slot A first, then B.
    if slot_vector_valid(0):
        predicted_slot = 0
    elif slot_vector_valid(1):
        predicted_slot = 1
    else:
        predicted_slot = -1

# ---------------------------------------------------------------------------
# Execute or static-analyze
# ---------------------------------------------------------------------------

if evaluation_mode == 'execute':
    monitor.Parse('machine Reset')
    monitor.Parse('emulation RunFor "0.5"')

    slot_marker = as_int(bus.ReadDoubleWord(0x10070220))
    if slot_marker in (0, 1):
        actual_slot = slot_marker
    else:
        # Slot marker not written (bootloader may not have reached that point).
        # Fall back to our prediction for recording purposes.
        actual_slot = predicted_slot
else:
    # State mode: use the predicted slot directly.
    actual_slot = predicted_slot

if actual_slot in (0, 1):
    boot_outcome = 'success'
    boot_slot = 'B' if actual_slot == 1 else 'A'
else:
    boot_outcome = 'hard_fault'
    boot_slot = None

# ---------------------------------------------------------------------------
# Emit result JSON
# ---------------------------------------------------------------------------

result = {
    'scenario_index': scenario_index,
    'boot_outcome': boot_outcome,
    'boot_slot': boot_slot,
    'predicted_slot': predicted_slot,
    'actual_slot': actual_slot,
    'match': (actual_slot == predicted_slot),
    'nvm_state': {
        'evaluation_mode': evaluation_mode,
        'requested_slot': requested_slot,
        'replica0': r0,
        'replica1': r1,
        'slot_a_vectors_valid': slot_vector_valid(0),
        'slot_b_vectors_valid': slot_vector_valid(1),
        'slot_a_sp': '0x{0:08X}'.format(as_int(bus.ReadDoubleWord(0x10002000))),
        'slot_a_reset': '0x{0:08X}'.format(as_int(bus.ReadDoubleWord(0x10002004))),
        'slot_b_sp': '0x{0:08X}'.format(as_int(bus.ReadDoubleWord(0x10039000))),
        'slot_b_reset': '0x{0:08X}'.format(as_int(bus.ReadDoubleWord(0x10039004))),
    },
}

with open(result_file, 'w') as f:
    f.write(json.dumps(result, indent=2, sort_keys=True))
"""
