# Live fault-point run for resilient OTA scenario.
# Required monitor variables:
#   $fault_at (int)
#   $total_writes (int)
#   $result_file (string path)
#   $include_metadata_faults (true/false)
# Optional monitor variables:
#   $repo_root (string path)
#   $slot_b_image (string path to slot B update image)
#   $evaluation_mode ("execute" or "state")

$fault_at?=0
$total_writes?=28160
$include_metadata_faults?=false
$slot_b_image?=""

python """
import json
import os
import struct

bus = monitor.Machine.SystemBus
ctrl = monitor.Machine['sysbus.nvm_ctrl']

fault_at = int(monitor.GetVariable('fault_at'))
total_writes = int(monitor.GetVariable('total_writes'))
result_file = str(monitor.GetVariable('result_file'))
include_metadata_faults = str(monitor.GetVariable('include_metadata_faults')).lower() in ('1', 'true', 'yes')
evaluation_mode = 'execute'
try:
    evaluation_mode = str(monitor.GetVariable('evaluation_mode')).strip().lower()
except Exception:
    evaluation_mode = 'execute'
if evaluation_mode not in ('execute', 'state'):
    evaluation_mode = 'execute'
repo_root = ''
slot_b_path = ''
META0_BASE = 0x10070000
META1_BASE = 0x10070100
BOOT_META_MAX_BOOT_COUNT = 3
BOOT_STATE_CONFIRMED = 0
BOOT_STATE_PENDING_TEST = 1

def as_int(value):
    try:
        return int(value) & 0xFFFFFFFF
    except Exception:
        return int(str(value), 0) & 0xFFFFFFFF

def boot_meta_crc_words(words):
    crc = 0xFFFFFFFF
    for word in words[:-1]:
        for shift in (0, 8, 16, 24):
            crc ^= (word >> shift) & 0xFF
            for _ in range(8):
                if crc & 1:
                    crc = (crc >> 1) ^ 0xEDB88320
                else:
                    crc >>= 1
                crc &= 0xFFFFFFFF
    return crc ^ 0xFFFFFFFF

def seq_ge(a, b):
    return ((a - b) & 0xFFFFFFFF) < 0x80000000

try:
    repo_root = str(monitor.GetVariable('repo_root'))
except Exception:
    pass

try:
    slot_b_path = str(monitor.GetVariable('slot_b_image'))
except Exception:
    slot_b_path = ''

if not slot_b_path:
    slot_b_path = 'examples/resilient_ota/slot_b.bin'
if not os.path.isabs(slot_b_path) and repo_root:
    slot_b_path = os.path.join(repo_root, slot_b_path)

with open(slot_b_path, 'rb') as f:
    slot_payload = f.read()
needed = total_writes * 8
if len(slot_payload) < needed:
    slot_payload = slot_payload + bytes(needed - len(slot_payload))
else:
    slot_payload = slot_payload[:needed]

state = {'index': 0, 'faulted': False, 'fault_address': 0}

def le64(chunk):
    return struct.unpack('<Q', chunk)[0]

def maybe_write_qword(addr, value):
    if state['faulted']:
        return False

    do_fault = (state['index'] == fault_at)
    if do_fault:
        ctrl.InjectPartialWrite(addr)
        state['faulted'] = True
        state['fault_address'] = addr
        return False

    bus.WriteQuadWord(addr, value)
    state['index'] += 1
    return True

def maybe_write_dword(addr, value):
    if state['faulted']:
        return False

    do_fault = (state['index'] == fault_at)
    if do_fault:
        ctrl.InjectPartialWrite(addr)
        state['faulted'] = True
        state['fault_address'] = addr
        return False

    bus.WriteDoubleWord(addr, value)
    state['index'] += 1
    return True

def build_meta_words(seq, active_slot, target_slot, state_code, boot_count, max_boot_count):
    words = [0] * 64
    words[0] = 0x4F54414D
    words[1] = seq & 0xFFFFFFFF
    words[2] = active_slot & 0xFFFFFFFF
    words[3] = target_slot & 0xFFFFFFFF
    words[4] = state_code & 0xFFFFFFFF
    words[5] = boot_count & 0xFFFFFFFF
    words[6] = max_boot_count & 0xFFFFFFFF
    words[-1] = boot_meta_crc_words(words)
    return words

# 1) Host writes new image to inactive slot (slot B).
for i in range(total_writes):
    addr = 0x10039000 + i * 8
    word = le64(slot_payload[i * 8:(i + 1) * 8])
    if not maybe_write_qword(addr, word):
        break

# 2) Firmware metadata update (non-primary replica first), optionally faultable.
if not state['faulted']:
    words = build_meta_words(
        seq=2,
        active_slot=1,
        target_slot=1,
        state_code=BOOT_STATE_PENDING_TEST,
        boot_count=0,
        max_boot_count=BOOT_META_MAX_BOOT_COUNT,
    )

    def write_metadata_replica(base):
        for i, word in enumerate(words):
            addr = base + i * 4
            if include_metadata_faults:
                if not maybe_write_dword(addr, word):
                    return False
            else:
                bus.WriteDoubleWord(addr, word)
        return True

    # Update the non-primary replica first to reduce the chance of losing the latest
    # valid state if a fault lands mid-update.
    if write_metadata_replica(META1_BASE):
        write_metadata_replica(META0_BASE)

def slot_base(slot_id):
    return 0x10039000 if slot_id == 1 else 0x10002000

def slot_vector_valid(slot_id):
    base = slot_base(slot_id)
    sp = as_int(bus.ReadDoubleWord(base + 0))
    reset_vector = as_int(bus.ReadDoubleWord(base + 4))
    reset_pc = reset_vector & ~1
    return (
        (0x20000000 <= sp <= 0x20020000)
        and ((reset_vector & 1) == 1)
        and (base <= reset_pc < (base + 0x37000))
    )

def read_replica(addr):
    words = []
    for i in range(64):
        words.append(as_int(bus.ReadDoubleWord(addr + i * 4)))

    valid = (words[0] == 0x4F54414D) and (words[-1] == boot_meta_crc_words(words))
    return {
        'valid': valid,
        'seq': words[1],
        'active_slot': words[2],
        'target_slot': words[3],
        'state': words[4],
        'boot_count': words[5],
        'max_boot_count': words[6],
    }

r0 = read_replica(META0_BASE)
r1 = read_replica(META1_BASE)

selected = None
if r0['valid'] and r1['valid']:
    selected = r0 if seq_ge(r0['seq'], r1['seq']) else r1
elif r0['valid']:
    selected = r0
elif r1['valid']:
    selected = r1

requested_slot = selected['active_slot'] if selected is not None else 0
metadata_repaired = False
chosen_slot = -1
if evaluation_mode == 'execute':
    monitor.Parse('machine Reset')
    monitor.Parse('emulation RunFor "0.1"')

    r0 = read_replica(META0_BASE)
    r1 = read_replica(META1_BASE)
    if r0['valid'] and r1['valid']:
        selected = r0 if seq_ge(r0['seq'], r1['seq']) else r1
    elif r0['valid']:
        selected = r0
    elif r1['valid']:
        selected = r1
    else:
        selected = None
    requested_slot = selected['active_slot'] if selected is not None else 0

    slot_marker = as_int(bus.ReadDoubleWord(0x10070220))
    if slot_marker in (0, 1):
        chosen_slot = slot_marker
else:
    chosen_slot = requested_slot
    if not slot_vector_valid(chosen_slot):
        other = 1 if chosen_slot == 0 else 0
        chosen_slot = other if slot_vector_valid(other) else -1

    if chosen_slot in (0, 1) and chosen_slot != requested_slot:
        source_seq = selected['seq'] if selected is not None else 0
        source_max = selected['max_boot_count'] if selected is not None else 0
        max_count = source_max if source_max != 0 else BOOT_META_MAX_BOOT_COUNT

        repair_words = build_meta_words(
            seq=(source_seq + 1) & 0xFFFFFFFF,
            active_slot=chosen_slot,
            target_slot=chosen_slot,
            state_code=BOOT_STATE_CONFIRMED,
            boot_count=0,
            max_boot_count=max_count,
        )

        first_base = META0_BASE
        second_base = META1_BASE
        if r0['valid'] and not r1['valid']:
            first_base = META1_BASE
            second_base = META0_BASE
        elif r0['valid'] and r1['valid']:
            if seq_ge(r0['seq'], r1['seq']):
                first_base = META1_BASE
                second_base = META0_BASE

        for i, value in enumerate(repair_words):
            bus.WriteDoubleWord(first_base + i * 4, value)
        for i, value in enumerate(repair_words):
            bus.WriteDoubleWord(second_base + i * 4, value)
        metadata_repaired = True

        r0 = read_replica(META0_BASE)
        r1 = read_replica(META1_BASE)
        if r0['valid'] and r1['valid']:
            selected = r0 if seq_ge(r0['seq'], r1['seq']) else r1
        elif r0['valid']:
            selected = r0
        elif r1['valid']:
            selected = r1
        else:
            selected = None

if chosen_slot in (0, 1):
    boot_outcome = 'success'
    boot_slot = 'B' if chosen_slot == 1 else 'A'
else:
    boot_outcome = 'hard_fault'
    boot_slot = None

result = {
    'fault_at': fault_at,
    'boot_outcome': boot_outcome,
    'boot_slot': boot_slot,
    'nvm_state': {
        'evaluation_mode': evaluation_mode,
        'chosen_slot': chosen_slot,
        'requested_slot': requested_slot,
        'write_index': state['index'],
        'faulted': state['faulted'],
        'fault_address': '0x{0:08X}'.format(state['fault_address']),
        'include_metadata_faults': include_metadata_faults,
        'replica0_valid': r0['valid'],
        'replica1_valid': r1['valid'],
        'replica0_seq': r0['seq'],
        'replica1_seq': r1['seq'],
        'metadata_repaired': metadata_repaired,
    },
}

with open(result_file, 'w') as f:
    f.write(json.dumps(result, sort_keys=True))
"""
