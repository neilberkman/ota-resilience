# Live fault-point run for vulnerable OTA scenario.
# Required monitor variables:
#   $fault_at (int)
#   $total_writes (int)
#   $result_file (string path)
# Optional monitor variables:
#   $evaluation_mode ("execute" or "state")

$fault_at?=0
$total_writes?=28672

python """
import json

bus = monitor.Machine.SystemBus
ctrl = monitor.Machine['sysbus.nvm_ctrl']
fault_at = int(monitor.GetVariable('fault_at'))
total_writes = int(monitor.GetVariable('total_writes'))
result_file = str(monitor.GetVariable('result_file'))
evaluation_mode = 'execute'
try:
    evaluation_mode = str(monitor.GetVariable('evaluation_mode')).strip().lower()
except Exception:
    evaluation_mode = 'execute'
if evaluation_mode not in ('execute', 'state'):
    evaluation_mode = 'execute'

COPY_MARKER_VALUE = 0xC0FEBEEF
COPY_MARKER_ADDR = 0x10070000
BOOT_COUNTER_ADDR = 0x10070004

def as_int(value):
    try:
        return int(value)
    except Exception:
        return int(str(value), 0)

fault_injected = False
for i in range(total_writes):
    src = 0x10038000 + i * 8
    dst = 0x10000000 + i * 8
    if i == fault_at:
        ctrl.InjectPartialWrite(dst)
        fault_injected = True
        break
    bus.WriteQuadWord(dst, bus.ReadQuadWord(src))

pre_boot_counter = as_int(bus.ReadDoubleWord(BOOT_COUNTER_ADDR))
if not fault_injected and evaluation_mode == 'state':
    bus.WriteDoubleWord(COPY_MARKER_ADDR, COPY_MARKER_VALUE)

if evaluation_mode == 'execute':
    monitor.Parse('machine Reset')
    monitor.Parse('emulation RunFor "0.1"')

copy_marker = bus.ReadDoubleWord(COPY_MARKER_ADDR)
boot_counter = bus.ReadDoubleWord(BOOT_COUNTER_ADDR)
sp = bus.ReadDoubleWord(0x10000000)
reset_vector = bus.ReadDoubleWord(0x10000004)

copy_marker = as_int(copy_marker)
boot_counter = as_int(boot_counter)
sp = as_int(sp)
reset_vector = as_int(reset_vector)

vector_valid = (
    (0x20000000 <= sp <= 0x20020000)
    and ((reset_vector & 1) == 1)
    and (0x10000000 <= (reset_vector & ~1) < 0x10038000)
)

if evaluation_mode == 'execute':
    boot_progress = (boot_counter != pre_boot_counter)
    copy_done = (copy_marker == COPY_MARKER_VALUE)
    if copy_done and boot_progress:
        boot_outcome = 'success'
        boot_slot = 'A'
    else:
        boot_outcome = 'hard_fault'
        boot_slot = None
else:
    copy_done = (copy_marker == COPY_MARKER_VALUE) and (not fault_injected)
    # A valid vector table alone is not enough: copy must complete atomically.
    # Mid-copy faults can leave execution-critical words corrupted even when SP/PC look plausible.
    if copy_done and vector_valid:
        boot_outcome = 'success'
        boot_slot = 'A'
    else:
        boot_outcome = 'hard_fault'
        boot_slot = None

result = {
    'fault_at': fault_at,
    'boot_outcome': boot_outcome,
    'boot_slot': boot_slot,
    'nvm_state': {
        'evaluation_mode': evaluation_mode,
        'copy_marker': '0x{0:08X}'.format(copy_marker),
        'boot_counter': boot_counter,
        'pre_boot_counter': pre_boot_counter,
        'copy_done': copy_done,
        'vector_sp': '0x{0:08X}'.format(sp),
        'vector_reset': '0x{0:08X}'.format(reset_vector),
        'vector_valid': vector_valid,
        'fault_injected': fault_injected,
    },
}

with open(result_file, 'w') as f:
    f.write(json.dumps(result, sort_keys=True))
"""
